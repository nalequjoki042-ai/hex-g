<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hex Game Multiplayer</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://unpkg.com/colyseus.js@0.15.0/dist/colyseus.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1e1c1a;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            font-family: 'Courier New', monospace;
        }

        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            pointer-events: none;
            z-index: 10;
        }

        #player-name {
            margin: 0;
            color: #e94560;
            font-size: 20px;
        }

        #debug-info {
            margin: 5px 0;
            font-size: 14px;
            color: #a2a2bd;
        }

        #leaderboard {
            margin-top: 15px;
            background: rgba(22, 33, 62, 0.8);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #0f3460;
            pointer-events: auto;
            max-width: 200px;
        }

        .leader-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .leader-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }

        canvas {
            display: block;
        }

        /* --- PLAYER MENU STYLES --- */
        #player-menu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 320px;
            background: #16213e;
            border: 2px solid #e94560;
            border-radius: 15px;
            padding: 20px;
            z-index: 100;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }

        #player-menu.active {
            display: block;
        }

        .menu-header {
            font-size: 20px;
            font-weight: bold;
            color: #e94560;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid #0f3460;
            padding-bottom: 10px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .stat-label {
            color: #a2a2bd;
        }

        .stat-value {
            font-weight: bold;
            color: #fff;
        }

        .close-btn {
            display: block;
            width: 100%;
            background: #e94560;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 8px;
            margin-top: 20px;
            font-weight: bold;
            cursor: pointer;
        }

        #menu-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 90;
        }

        #menu-overlay.active {
            display: block;
        }

        .profile-btn {
            margin-top: 15px;
            background: #0f3460;
            color: #fff;
            border: 1px solid #e94560;
            padding: 8px 15px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            pointer-events: auto;
            width: 100%;
        }

        .settings-btn {
            margin-top: 8px;
            background: #16213e;
            color: #a2a2bd;
            border: 1px solid #0f3460;
            padding: 5px 15px;
            border-radius: 8px;
            font-size: 12px;
            cursor: pointer;
            pointer-events: auto;
            width: 100%;
        }

        /* --- UI TOGGLE MENU STYLES --- */
        #settings-menu {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 85%;
            max-width: 320px;
            background: #16213e;
            border: 2px solid #4ecca3;
            border-radius: 15px;
            padding: 20px;
            z-index: 101;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }

        #settings-menu.active {
            display: block;
        }

        .toggle-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 10px;
            background: rgba(15, 52, 96, 0.5);
            border-radius: 8px;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #0f3460;
            transition: .4s;
            border-radius: 20px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #4ecca3;
        }

        input:checked + .slider:before {
            transform: translateX(20px);
        }

        /* --- CONTEXT MENU STYLES --- */
        #context-menu {
            display: none;
            position: fixed;
            background: #16213e;
            border: 1px solid #e94560;
            border-radius: 8px;
            padding: 5px 0;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            min-width: 150px;
        }

        .context-item {
            padding: 8px 15px;
            color: #fff;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }

        .context-item:hover {
            background: #0f3460;
        }

        .context-item.header {
            border-bottom: 1px solid #0f3460;
            color: #a2a2bd;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            pointer-events: none;
        }

        /* --- TOAST NOTIFICATIONS --- */
        #toast-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 2000;
            pointer-events: none;
        }

        .toast {
            background: rgba(22, 33, 62, 0.95);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            border: 1px solid #e94560;
            font-size: 14px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            animation: toast-in 0.3s ease-out, toast-out 0.3s ease-in 2.7s forwards;
            white-space: nowrap;
        }

        .toast.success { border-color: #4ecca3; }
        .toast.error { border-color: #e94560; }
        .toast.info { border-color: #00d2ff; }

        @keyframes toast-in {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        @keyframes toast-out {
            from { transform: translateY(0); opacity: 1; }
            to { transform: translateY(-20px); opacity: 0; }
        }
    </style>
</head>

<body>
    <div id="toast-container"></div>
    <div id="ui">
        <h3 id="player-name">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</h3>
        <p id="debug-info">–ü–æ–¥–æ–∂–¥–∏—Ç–µ...</p>
        <div id="energy-bar" style="margin: 10px 0; background: #16213e; border: 1px solid #0f3460; border-radius: 5px; height: 10px; width: 150px; overflow: hidden; pointer-events: auto;">
            <div id="energy-fill" style="background: #4ecca3; height: 100%; width: 100%; transition: width 0.3s;"></div>
        </div>
        <div id="energy-text" style="font-size: 12px; color: #4ecca3; margin-bottom: 10px;">–≠–Ω–µ—Ä–≥–∏—è: 10/10</div>
        
        <div id="leaderboard">
            <div style="font-weight: bold; margin-bottom: 8px; color: #e94560;">–†–µ—Å—É—Ä—Å—ã:</div>
            <div id="player-resources" style="font-size: 14px; margin-bottom: 10px;">
                –î–µ—Ä–µ–≤–æ: 0 | –ö–∞–º–µ–Ω—å: 0 | –°–∫—Ä–∞–ø: 0
            </div>
            <div style="font-weight: bold; margin-bottom: 8px; color: #e94560;">–¢–æ–ø –∑–∞—Ö–≤–∞—Ç—á–∏–∫–æ–≤:</div>
            <div id="leader-list">
                <!-- –°—é–¥–∞ –ø–æ–ø–∞–¥—É—Ç –∏–≥—Ä–æ–∫–∏ -->
            </div>
        </div>

        <button class="profile-btn" onclick="toggleMenu()">üìä –ú–æ—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</button>
        <button class="settings-btn" onclick="toggleSettings()">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ UI</button>
    </div>

    <!-- UI Settings Menu -->
    <div id="settings-menu">
        <div class="menu-header" style="color: #4ecca3; border-color: #4ecca3;">–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞</div>
        <div class="toggle-row">
            <span>–ò–º—è –∏–≥—Ä–æ–∫–∞</span>
            <label class="switch">
                <input type="checkbox" checked onchange="toggleUI('player-name', this.checked)">
                <span class="slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span>–≠–Ω–µ—Ä–≥–∏—è</span>
            <label class="switch">
                <input type="checkbox" checked onchange="toggleUI('energy-group', this.checked)">
                <span class="slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span>–¢–∞–±–ª–∏—Ü–∞ –ª–∏–¥–µ—Ä–æ–≤</span>
            <label class="switch">
                <input type="checkbox" checked onchange="toggleUI('leaderboard', this.checked)">
                <span class="slider"></span>
            </label>
        </div>
        <div class="toggle-row">
            <span>–ö–Ω–æ–ø–∫–∞ –ø—Ä–æ—Ñ–∏–ª—è</span>
            <label class="switch">
                <input type="checkbox" checked onchange="toggleUI('profile-btn', this.checked)">
                <span class="slider"></span>
            </label>
        </div>
        <button class="close-btn" style="background: #4ecca3;" onclick="toggleSettings()">–ì–æ—Ç–æ–≤–æ</button>
    </div>

    <!-- Context Menu -->
    <div id="context-menu">
        <div class="context-item header" id="context-title">–û–±—ä–µ–∫—Ç: –ì–µ–∫—Å</div>
        <div class="context-item" onclick="handleContextAction('info')">‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è</div>
        <div class="context-item" onclick="handleContextAction('claim')">üö© –ó–∞—Ö–≤–∞—Ç–∏—Ç—å</div>
        <div class="context-item" id="context-build-tc" onclick="handleContextAction('buildTC')">üî® –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –®–∫–∞—Ñ (200 –î–µ—Ä–µ–≤–∞)</div>
    </div>

    <div id="menu-overlay" onclick="closeAllMenus()"></div>
    <div id="player-menu">
        <div class="menu-header">–ü—Ä–æ—Ñ–∏–ª—å –ö–æ–º–∞–Ω–¥–∏—Ä–∞</div>
        <div id="menu-stats">
            <div class="stat-row">
                <span class="stat-label">–ò–º—è:</span>
                <span class="stat-value" id="stat-name">-</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">–ó–∞—Ö–≤–∞—á–µ–Ω–æ –≥–µ–∫—Å–æ–≤:</span>
                <span class="stat-value" id="stat-hexes">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">–¢–µ–∫—É—â–∞—è —ç–Ω–µ—Ä–≥–∏—è:</span>
                <span class="stat-value" id="stat-energy">0/10</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">–í–∞—à —Ü–≤–µ—Ç:</span>
                <span class="stat-value"><span id="stat-color" style="display:inline-block; width:15px; height:15px; border-radius:50%; vertical-align:middle; border:1px solid #fff;"></span></span>
            </div>
        </div>
        <button class="close-btn" onclick="toggleMenu()">–ó–∞–∫—Ä—ã—Ç—å</button>
    </div>

    <canvas id="game-canvas"></canvas>

    <script>
        // --- 1. –¢–ï–õ–ï–ì–†–ê–ú –ò –î–ê–ù–ù–´–ï –ò–ì–†–û–ö–ê ---
        const tg = window.Telegram.WebApp;
        tg.expand();
        let myName = "–ö–æ–º–∞–Ω–¥–∏—Ä " + Math.floor(Math.random() * 1000);
        if (tg.initDataUnsafe?.user) {
            myName = tg.initDataUnsafe.user.first_name;
        }

        // --- 2. –ù–ê–°–¢–†–û–ô–ö–ê –ö–ê–†–¢–´ –ò –û–¢–†–ò–°–û–í–ö–ò ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        // --- –ü–ê–†–ê–ú–ï–¢–†–´ –ö–ê–ú–ï–†–´ ---
        let camX = 0;
        let camY = 0;
        let zoom = 1.0;
        const minZoom = 0.5; // –û–≥—Ä–∞–Ω–∏—á–∏–ª–∏ –º–∏–Ω. –∑—É–º, —á—Ç–æ–±—ã –Ω–µ —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å –≤—Å—é –∫–∞—Ä—Ç—É
        const maxZoom = 2.0;
        const panSpeed = 10;

        // –õ–∏–º–∏—Ç—ã –∫–∞–º–µ—Ä—ã –¥–ª—è –∫–∞—Ä—Ç—ã —Ä–∞–¥–∏—É—Å–æ–º ~50 –≥–µ–∫—Å–æ–≤
        const MAP_RADIUS_HEX = 50;
        const MAP_RADIUS_PX = MAP_RADIUS_HEX * 35 * 1.5;
        
        const keysPressed = {};
        let isPanning = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        const hexSizeBase = 35;
        // hexSize —Ç–µ–ø–µ—Ä—å –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∑—É–º–∞
        function getHexSize() { return hexSizeBase * zoom; }

        function getOriginX() { return (canvas.width / 2) + camX; }
        function getOriginY() { return (canvas.height / 2 + 50) + camY; }

        // –¢–µ–ø–µ—Ä—å –∑–¥–µ—Å—å –º—ã —Ö—Ä–∞–Ω–∏–º –æ–±—ä–µ–∫—Ç—ã {owner, color, type, building}
        const capturedHexes = new Map();
        const clientUnits = new Map();
        let playerResources = { wood: 0, stone: 0, scrap: 0 };

        // VFX arrays
        let floatingTexts = [];
        let particles = [];
        let projectiles = [];
        let screenShake = 0;

        function drawHex(q, r, color, text = "", type = "plain", building = undefined) {
            const hSize = getHexSize();
            const oX = getOriginX();
            const oY = getOriginY();
            
            const x = oX + hSize * Math.sqrt(3) * (q + r / 2);
            const y = oY + hSize * 3 / 2 * r;

            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle_rad = Math.PI / 180 * (60 * i - 30);
                const px = x + hSize * Math.cos(angle_rad);
                const py = y + hSize * Math.sin(angle_rad);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.closePath();

            if (type === 'forest') {
                ctx.fillStyle = '#4a5438';
            } else if (type === 'mountain') {
                ctx.fillStyle = '#4b4b4b';
            } else if (type === 'ruins') {
                ctx.fillStyle = '#8f8f00'; // Radioactive
            } else {
                ctx.fillStyle = color !== '#16213e' ? color : '#5c5346';
            }

            ctx.fill();
            ctx.strokeStyle = '#111';
            ctx.lineWidth = 4 * zoom;
            ctx.stroke();

            if (zoom > 0.5) {
                ctx.globalAlpha = 0.5;
                ctx.fillStyle = '#ffffff';
                ctx.font = `bold ${Math.floor(20 * zoom)}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                let icon = "";
                if (type === 'forest') icon = "üå≤";
                else if (type === 'mountain') icon = "‚õ∞Ô∏è";
                else if (type === 'ruins') icon = "‚ò¢Ô∏è";

                if (icon) {
                    ctx.fillText(icon, x, y - 5*zoom);
                } else if (text && !building) {
                    // Draw owner initial if it's a claimed plain hex
                    ctx.globalAlpha = 1.0;
                    ctx.font = `bold ${Math.floor(16 * zoom)}px Courier New`;
                    ctx.fillText(text.charAt(0).toUpperCase(), x, y);
                }

                if (building === 'TC') {
                    // Draw Town Cabinet
                    ctx.globalAlpha = 1.0;
                    ctx.fillStyle = '#8B4513';
                    ctx.fillRect(x - 15*zoom, y - 10*zoom, 30*zoom, 25*zoom);
                    ctx.strokeStyle = '#222';
                    ctx.lineWidth = 2 * zoom;
                    ctx.strokeRect(x - 15*zoom, y - 10*zoom, 30*zoom, 25*zoom);

                    ctx.font = `${Math.floor(18 * zoom)}px Arial`;
                    ctx.fillText("üèõÔ∏è", x, y + 2*zoom);
                }
                ctx.globalAlpha = 1.0;
            }
        }

        function drawUnit(ctx, unit, oX, oY, hSize) {
            let bounceY = Math.sin(Date.now() / 150) * 4;

            // Camera offsets for rendering
            let uX = oX + unit.x * zoom;
            let uY = oY + unit.y * zoom + bounceY * zoom;
            let drawSize = 25 * zoom;

            // –¢–µ–Ω—å
            ctx.beginPath();
            ctx.ellipse(uX, uY + drawSize, drawSize * 0.8, drawSize * 0.32, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0,0,0,0.4)';
            ctx.fill();

            // –¢–µ–ª–æ —Ñ–∏—à–∫–∏
            ctx.beginPath();
            ctx.arc(uX, uY, drawSize, 0, Math.PI * 2);
            ctx.fillStyle = '#222';
            ctx.fill();
            ctx.lineWidth = 4 * zoom;

            if (window.selectedUnitId === unit.id) {
                ctx.strokeStyle = '#fff';
            } else {
                ctx.strokeStyle = unit.color; // –¶–≤–µ—Ç –∫–ª–∞–Ω–∞
            }
            ctx.stroke();

            // –ò–∫–æ–Ω–∫–∞ (–í –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞)
            ctx.font = `${Math.floor(24 * zoom)}px Arial`;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            let icon = unit.type === 'farmer' ? "ü™ì" : "üî´";
            if (unit.type === 'founder') icon = "üë§";
            ctx.fillText(icon, uX, uY + 2 * zoom);

            drawUnitUI(ctx, unit, uX, uY, drawSize);
        }

        function drawUnitUI(ctx, unit, uX, uY, drawSize) {
            // –ü–æ–ª–æ—Å–∫–∞ HP
            let hpX = uX - drawSize, hpY = uY - drawSize * 1.6;
            let hpWidth = drawSize * 2;
            let hpHeight = 6 * zoom;

            ctx.fillStyle = '#000';
            ctx.fillRect(hpX, hpY, hpWidth, hpHeight);
            let hpPercent = unit.hp / unit.maxHp;
            ctx.fillStyle = hpPercent > 0.5 ? '#4caf50' : '#ff9800';
            ctx.fillRect(hpX, hpY, hpWidth * hpPercent, hpHeight);
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 1 * zoom;
            ctx.strokeRect(hpX, hpY, hpWidth, hpHeight);

            // –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å
            if (unit.inventory !== undefined && unit.maxInventory > 0) {
                ctx.fillStyle = "rgba(0,0,0,0.6)";
                ctx.roundRect(uX - drawSize * 1.4, uY + drawSize * 1.2, drawSize * 2.8, 18 * zoom, 4 * zoom);
                ctx.fill();
                ctx.font = `bold ${Math.floor(12 * zoom)}px Courier New`;
                ctx.fillStyle = "#e6a822";
                ctx.fillText(`üéí ${Math.floor(unit.inventory)}/${unit.maxInventory}`, uX, uY + drawSize * 1.6);
            }
        }

        function drawMap() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            if (screenShake > 0.5) {
                ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
                screenShake *= 0.85; // –ó–∞—Ç—É—Ö–∞–Ω–∏–µ
            }

            const hSize = getHexSize();
            const oX = getOriginX();
            const oY = getOriginY();

            // 1. –û–ü–†–ï–î–ï–õ–Ø–ï–ú –í–ò–î–ò–ú–£–Æ –û–ë–õ–ê–°–¢–¨ (–≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞—Ö Q, R)
            // –ú—ã –±–µ—Ä–µ–º —É–≥–ª—ã —ç–∫—Ä–∞–Ω–∞ –∏ –ø–µ—Ä–µ–≤–æ–¥–∏–º –∏—Ö –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –≥–µ–∫—Å–æ–≤
            const screenPadding = hSize * 2; // –ù–µ–±–æ–ª—å—à–æ–π –∑–∞–ø–∞—Å –ø–æ –∫—Ä–∞—è–º
            
            function getQR(x, y) {
                const q = (Math.sqrt(3) / 3 * (x - oX) - 1 / 3 * (y - oY)) / hSize;
                const r = (2 / 3 * (y - oY)) / hSize;
                return hexRound(q, r);
            }

            // –ù–∞—Ö–æ–¥–∏–º QR –¥–ª—è –≤—Å–µ—Ö 4 —É–≥–ª–æ–≤ —ç–∫—Ä–∞–Ω–∞, —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –æ—Ö–≤–∞—Ç–∏—Ç—å –≤–∏–¥–∏–º—É—é –æ–±–ª–∞—Å—Ç—å
            const corners = [
                getQR(0, 0),
                getQR(canvas.width, 0),
                getQR(0, canvas.height),
                getQR(canvas.width, canvas.height)
            ];

            const qStart = Math.min(...corners.map(c => c.q)) - 2;
            const qEnd = Math.max(...corners.map(c => c.q)) + 2;
            const rStart = Math.min(...corners.map(c => c.r)) - 2;
            const rEnd = Math.max(...corners.map(c => c.r)) + 2;

            for (let q = qStart; q <= qEnd; q++) {
                for (let r = rStart; r <= rEnd; r++) {
                    const key = `${q},${r}`;
                    if (capturedHexes.has(key)) {
                        const data = capturedHexes.get(key);
                        // Fog of War rendering: Data exists only if visible to player (because of @filter on server)
                        // If color/owner is not synced, we draw it as unexplored or dim.
                        // Wait, server @filter returns default schema state if filtered.
                        // So owner might be "", type might be "".

                        let hexColor = data.color || '#1e1c1a';
                        let hexType = data.type || 'plain';

                        drawHex(q, r, hexColor, data.owner, hexType, data.building);
                    } else {
                        // Unexplored/Fog area
                        if (Math.abs(q) <= 50 && Math.abs(r) <= 50 && Math.abs(-q-r) <= 50) {
                            drawHex(q, r, '#111', "", "plain");
                        }
                    }
                }
            }
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ —Ä–∏—Å—É–µ–º –∑–∞—Ö–≤–∞—á–µ–Ω–Ω—ã–µ –≥–µ–∫—Å—ã, –µ—Å–ª–∏ –æ–Ω–∏ –≤ —ç–∫—Ä–∞–Ω–µ (–Ω–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ q/r –≤–Ω–µ —Ü–∏–∫–ª–∞)
            capturedHexes.forEach((data, key) => {
                const [q, r] = key.split(',').map(Number);
                if (q < qStart || q > qEnd || r < rStart || r > rEnd) {
                    const x = oX + hSize * Math.sqrt(3) * (q + r / 2);
                    const y = oY + hSize * 3 / 2 * r;
                    if (x > -screenPadding && x < canvas.width + screenPadding &&
                        y > -screenPadding && y < canvas.height + screenPadding) {
                        let hexColor = data.color || '#1e1c1a';
                        let hexType = data.type || 'plain';
                        drawHex(q, r, hexColor, data.owner, hexType, data.building);
                    }
                }
            });

            // Draw units
            clientUnits.forEach(unit => {
                drawUnit(ctx, unit, oX, oY, hSize);
            });

            // --- –û–¢–†–ò–°–û–í–ö–ê –ß–ê–°–¢–ò–¶ (–ö—Ä–æ–≤—å, –ò—Å–∫—Ä—ã, –î—ã–º, –ì–∏–ª—å–∑—ã) ---
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];

                // –§–∏–∑–∏–∫–∞ –ø–æ–≤–µ–¥–µ–Ω–∏—è –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–∏–ø–∞
                if (p.type === 'smoke' || p.type === 'fire') {
                    p.x += p.vx; p.y += p.vy;
                    p.size += (p.type === 'smoke' ? 0.3 : 0.8); // –î—ã–º/–û–≥–æ–Ω—å —Ä–∞—Å—à–∏—Ä—è–µ—Ç—Å—è
                } else {
                    p.vy += 0.8; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –¥–ª—è –∫—Ä–æ–≤–∏, –∏—Å–∫—Ä –∏ –≥–∏–ª—å–∑
                    p.x += p.vx; p.y += p.vy;
                }

                p.life -= 0.03;
                if (p.life <= 0) { particles.splice(i, 1); continue; }

                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                if (p.type === 'smoke' || p.type === 'fire' || p.type === 'blood') {
                    ctx.arc(oX + p.x * zoom, oY + p.y * zoom, p.size * zoom, 0, Math.PI*2);
                } else {
                    ctx.fillRect(oX + p.x * zoom, oY + p.y * zoom, p.size * zoom, p.size * zoom); // –ò—Å–∫—Ä—ã –∏ –≥–∏–ª—å–∑—ã –∫–≤–∞–¥—Ä–∞—Ç–Ω—ã–µ
                }
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            // --- –û–¢–†–ò–°–û–í–ö–ê –¢–ï–ö–°–¢–ê –£–†–û–ù–ê / –°–ë–û–†–ê (VFX) ---
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                let t = floatingTexts[i];
                ctx.globalAlpha = Math.max(0, t.alpha);

                // Using scale if exists, else default to 1
                let scale = t.scale || 1.0;
                ctx.font = `bold ${Math.floor(20 * scale * zoom)}px Courier New`;
                ctx.fillStyle = t.color || '#fff';
                ctx.strokeStyle = '#111';
                ctx.lineWidth = 4 * zoom;

                // Position based on world coordinates
                let tX = oX + t.x * zoom;
                let tY = oY + t.y * zoom;
                ctx.strokeText(t.text, tX, tY);
                ctx.fillText(t.text, tX, tY);
                ctx.globalAlpha = 1.0;

                t.y -= 1.5;
                t.alpha -= 0.02;
                if (t.alpha <= 0) floatingTexts.splice(i, 1);
            }

            ctx.restore();

            updateLeaderboard();
        }

        // --- –¶–ò–ö–õ –û–ë–ù–û–í–õ–ï–ù–ò–Ø (–î–ª—è –ø–ª–∞–≤–Ω–æ–π –∫–∞–º–µ—Ä—ã) ---
        function update() {
            let moved = false;
            if (keysPressed['KeyW'] || keysPressed['ArrowUp']) { camY += panSpeed; moved = true; }
            if (keysPressed['KeyS'] || keysPressed['ArrowDown']) { camY -= panSpeed; moved = true; }
            if (keysPressed['KeyA'] || keysPressed['ArrowLeft']) { camX += panSpeed; moved = true; }
            if (keysPressed['KeyD'] || keysPressed['ArrowRight']) { camX -= panSpeed; moved = true; }

            if (moved) constrainCamera();

            // –í—Å–µ–≥–¥–∞ —Ä–∏—Å—É–µ–º –∏–∑-–∑–∞ VFX –∏ –∞–Ω–∏–º–∞—Ü–∏–∏ —é–Ω–∏—Ç–æ–≤
            drawMap();
            requestAnimationFrame(update);
        }

        function constrainCamera() {
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∫–∞—Ä—Ç—ã
            const maxOffset = MAP_RADIUS_PX * zoom;
            if (camX > maxOffset) camX = maxOffset;
            if (camX < -maxOffset) camX = -maxOffset;
            if (camY > maxOffset) camY = maxOffset;
            if (camY < -maxOffset) camY = -maxOffset;
        }
        update();

        // --- –û–ë–†–ê–ë–û–¢–ö–ê –í–í–û–î–ê ---
        window.addEventListener('keydown', (e) => {
            keysPressed[e.code] = true;
            if (e.code === 'F1' || e.code === 'KeyC') {
                e.preventDefault();
                centerCameraOnPlayer();
            }
        });
        window.addEventListener('keyup', (e) => { keysPressed[e.code] = false; });

        function centerCameraOnPlayer() {
            // –ò—â–µ–º —Å–Ω–∞—á–∞–ª–∞ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ —é–Ω–∏—Ç–∞, –ø–æ—Ç–æ–º –ª—é–±–æ–≥–æ —Å–≤–æ–µ–≥–æ —é–Ω–∏—Ç–∞, –ø–æ—Ç–æ–º —Å–≤–æ–π –¢–°
            let targetX = null;
            let targetY = null;

            if (window.selectedUnitId && clientUnits.has(window.selectedUnitId)) {
                let u = clientUnits.get(window.selectedUnitId);
                targetX = u.x;
                targetY = u.y;
            } else {
                // –ò—â–µ–º –ø–µ—Ä–≤–æ–≥–æ —Å–≤–æ–µ–≥–æ —é–Ω–∏—Ç–∞
                for (let [id, u] of clientUnits) {
                    if (u.owner === myName) {
                        targetX = u.x;
                        targetY = u.y;
                        break;
                    }
                }

                // –ï—Å–ª–∏ —é–Ω–∏—Ç–æ–≤ –Ω–µ—Ç, –∏—â–µ–º –¢–°
                if (targetX === null) {
                    for (let [id, hex] of capturedHexes) {
                        if (hex.owner === myName && hex.building === 'TC') {
                            const [q, r] = id.split(',').map(Number);
                            const hSize = hexSizeBase;
                            targetX = hSize * Math.sqrt(3) * (q + r / 2);
                            targetY = hSize * 3 / 2 * r;
                            break;
                        }
                    }
                }
            }

            if (targetX !== null && targetY !== null) {
                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –∫–∞–º–µ—Ä—É (camX/camY - —ç—Ç–æ —Å–º–µ—â–µ–Ω–∏–µ origin)
                camX = -targetX * zoom;
                camY = -targetY * zoom;
                constrainCamera();
                drawMap();
            }
        }

        // –ö–æ–ª–µ—Å–∏–∫–æ –º—ã—à–∏ (Zoom)
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            const newZoom = zoom * delta;
            
            if (newZoom >= minZoom && newZoom <= maxZoom) {
                // –ü—ã—Ç–∞–µ–º—Å—è –∑—É–º–∏—Ç—å –≤ —Ç–æ—á–∫—É –∫—É—Ä—Å–æ—Ä–∞
                const mouseX = e.clientX - canvas.width / 2;
                const mouseY = e.clientY - canvas.height / 2;
                
                // –ö–æ—Ä—Ä–µ–∫—Ç–∏—Ä—É–µ–º —Å–º–µ—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã, —á—Ç–æ–±—ã —Ç–æ—á–∫–∞ –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º –æ—Å—Ç–∞–ª–∞—Å—å –Ω–∞ –º–µ—Å—Ç–µ
                camX -= (mouseX - camX) * (delta - 1);
                camY -= (mouseY - camY) * (delta - 1);
                
                zoom = newZoom;
                drawMap();
            }
        }, { passive: false });

        // –ó–∞–∂–∞—Ç–æ–µ –∫–æ–ª–µ—Å–∏–∫–æ (Pan)
        canvas.addEventListener('pointerdown', (e) => {
            if (e.button === 1) { // –°—Ä–µ–¥–Ω—è—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
                isPanning = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
                e.preventDefault();
            }
        });

        window.addEventListener('pointermove', (e) => {
            if (isPanning) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                camX += dx;
                camY += dy;
                constrainCamera();
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                drawMap();
            }
        });

        window.addEventListener('pointerup', (e) => {
            if (e.button === 1) {
                isPanning = false;
                canvas.style.cursor = 'default';
            }
        });

        function updateLeaderboard() {
            try {
                const stats = {};
                capturedHexes.forEach(data => {
                    if (data && data.owner) {
                        if (!stats[data.owner]) {
                            stats[data.owner] = { count: 0, color: data.color };
                        }
                        stats[data.owner].count++;
                    }
                });

                const sorted = Object.entries(stats).sort((a, b) => b[1].count - a[1].count);
                const list = document.getElementById('leader-list');
                list.innerHTML = '';

                sorted.slice(0, 5).forEach(([name, data]) => {
                    const item = document.createElement('div');
                    item.className = 'leader-item';

                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º textContent –¥–ª—è –∏–º–µ–Ω–∏ –∏–≥—Ä–æ–∫–∞ –¥–ª—è –∑–∞—â–∏—Ç—ã –æ—Ç XSS
                    const nameSpan = document.createElement('span');
                    const colorCircle = document.createElement('span');
                    colorCircle.className = 'leader-color';
                    colorCircle.style.backgroundColor = data.color;
                    
                    nameSpan.appendChild(colorCircle);
                    nameSpan.appendChild(document.createTextNode(name));

                    const countSpan = document.createElement('span');
                    countSpan.style.fontWeight = 'bold';
                    countSpan.textContent = data.count;

                    item.appendChild(nameSpan);
                    item.appendChild(countSpan);
                    list.appendChild(item);
                });
            } catch (e) { console.error("Leaderboard update error:", e); }
        }

        // --- 3. –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï –ö –°–ï–†–í–ï–†–£ (–ú–£–õ–¨–¢–ò–ü–õ–ï–ï–†) ---
        const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const serverUrl = `${protocol}://${window.location.host}`;
        const client = new Colyseus.Client(serverUrl);

        let gameRoom;
        let currentEnergy = 10;
        let selectedHex = null; // –î–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –≥–µ–∫—Å–∞
        window.selectedUnitId = null; // –í—ã–±—Ä–∞–Ω–Ω—ã–π —é–Ω–∏—Ç

        function toggleMenu() {
            const menu = document.getElementById('player-menu');
            const overlay = document.getElementById('menu-overlay');
            const isActive = menu.classList.toggle('active');
            overlay.classList.toggle('active');
            
            if (isActive) {
                updateProfileStats();
                tg.HapticFeedback.impactOccurred('light');
            }
        }

        function toggleSettings() {
            const settings = document.getElementById('settings-menu');
            const overlay = document.getElementById('menu-overlay');
            const isActive = settings.classList.toggle('active');
            overlay.classList.toggle('active');
            
            if (isActive) {
                tg.HapticFeedback.impactOccurred('light');
            }
        }

        function closeAllMenus() {
            document.getElementById('player-menu').classList.remove('active');
            document.getElementById('settings-menu').classList.remove('active');
            document.getElementById('menu-overlay').classList.remove('active');
            closeContextMenu();
        }

        function toggleUI(block, isVisible) {
            const display = isVisible ? 'block' : 'none';
            const flexDisplay = isVisible ? 'flex' : 'none';

            if (block === 'player-name') {
                document.getElementById('player-name').style.display = display;
            } else if (block === 'energy-group') {
                document.getElementById('energy-bar').style.display = isVisible ? 'block' : 'none';
                document.getElementById('energy-text').style.display = isVisible ? 'block' : 'none';
            } else if (block === 'leaderboard') {
                document.getElementById('leaderboard').style.display = isVisible ? 'block' : 'none';
            } else if (block === 'profile-btn') {
                document.querySelector('.profile-btn').style.display = isVisible ? 'block' : 'none';
            }
            
            tg.HapticFeedback.selectionChanged();
        }

        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            
            // 1. –î–ª—è —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –æ—à–∏–±–æ–∫ –∏ –æ–±—â–∏—Ö –∏–Ω—Ñ–æ-—Å–æ–æ–±—â–µ–Ω–∏–π: –∏—â–µ–º –ø–æ —Ç–µ–∫—Å—Ç—É (–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ x1, x2)
            // 2. –î–ª—è –∑–∞—Ö–≤–∞—Ç–∞ —Å–µ–∫—Ç–æ—Ä–æ–≤: –∏—â–µ–º –ø–æ —Ç–∏–ø—É 'success', —á—Ç–æ–±—ã –ø—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–∏—Ç—å –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
            let existingToast = Array.from(container.children).find(t => {
                if (type === 'success') return t.classList.contains('success');
                return t.dataset.originalMessage === message;
            });
            
            if (existingToast) {
                if (type === 'success') {
                    // –ü—Ä–æ—Å—Ç–æ –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç –Ω–∞ –Ω–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                    existingToast.innerText = message;
                } else {
                    // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –¥–ª—è –æ—à–∏–±–æ–∫/–∏–Ω—Ñ–æ
                    let count = parseInt(existingToast.dataset.count || 1) + 1;
                    existingToast.dataset.count = count;
                    existingToast.innerText = `${message} (x${count})`;
                }
                
                // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é
                existingToast.style.animation = 'none';
                existingToast.offsetHeight;
                existingToast.style.animation = 'toast-in 0.3s ease-out, toast-out 0.3s ease-in 2.7s forwards';
                
                clearTimeout(existingToast.timeoutId);
                existingToast.timeoutId = setTimeout(() => {
                    existingToast.remove();
                }, 3000);
                
                return;
            }

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerText = message;
            toast.dataset.originalMessage = message;
            toast.dataset.count = 1;
            
            container.appendChild(toast);
            
            toast.timeoutId = setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function closeContextMenu() {
            document.getElementById('context-menu').style.display = 'none';
        }

        function handleContextAction(action) {
            if (!selectedHex) return;
            const { q, r } = selectedHex;
            const key = `${q},${r}`;
            const data = capturedHexes.get(key);

            if (action === 'info') {
                console.log(`[MENU] –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–± –æ–±—ä–µ–∫—Ç–µ: –ì–µ–∫—Å (${key})`);
                console.log(`[MENU] –í–ª–∞–¥–µ–ª–µ—Ü: ${data ? data.owner : '–ù–∏–∫—Ç–æ'}`);
                
                // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–∞—à —à–∞–±–ª–æ–Ω –º–µ–Ω—é –¥–ª—è –≤—ã–≤–æ–¥–∞ –∏–Ω—Ñ—ã
                const menu = document.getElementById('player-menu');
                const overlay = document.getElementById('menu-overlay');
                
                document.querySelector('.menu-header').innerText = "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ–∫—Ç–æ—Ä–µ";
                document.getElementById('stat-name').innerText = `–ì–µ–∫—Å [${key}]`;
                document.getElementById('stat-hexes').innerText = data && data.owner ? data.owner : "–°–≤–æ–±–æ–¥–µ–Ω";
                document.getElementById('stat-energy').innerText = data && data.building ? `–ó–¥–∞–Ω–∏–µ: ${data.building}` : "–î–æ—Å—Ç—É–ø–µ–Ω";
                document.getElementById('stat-color').style.background = data && data.color ? data.color : "#16213e";
                
                menu.classList.add('active');
                overlay.classList.add('active');
            } else if (action === 'claim') {
                gameRoom.send("claimHex", { q, r });
            } else if (action === 'buildTC') {
                if (window.selectedUnitId) {
                    gameRoom.send("buildTC", { unitId: window.selectedUnitId, q, r });
                } else {
                    showToast("–í—ã–±–µ—Ä–∏—Ç–µ —é–Ω–∏—Ç–∞!", "error");
                }
            }
            closeContextMenu();
        }

        function updateProfileStats() {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –º–µ–Ω—é –≤ –¥–µ—Ñ–æ–ª—Ç
            document.querySelector('.menu-header').innerText = "–ü—Ä–æ—Ñ–∏–ª—å –ö–æ–º–∞–Ω–¥–∏—Ä–∞";
            let myHexCount = 0;
            let myColor = '#16213e';
            
            capturedHexes.forEach(data => {
                if (data.owner === myName) {
                    myHexCount++;
                    myColor = data.color;
                }
            });

            document.getElementById('stat-name').innerText = myName;
            document.getElementById('stat-hexes').innerText = myHexCount;
            document.getElementById('stat-energy').innerText = `${currentEnergy}/10`;
            document.getElementById('stat-color').style.background = myColor;
        }

        async function connect() {
            try {
                gameRoom = await client.joinOrCreate("hex_game", { name: myName });
                console.log("Connected to room:", gameRoom.name);

                document.getElementById('player-name').innerText = `–ö–æ–º–∞–Ω–¥–∏—Ä: ${myName}`;
                document.getElementById('debug-info').innerText = '–°–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!';

                // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Ä–µ—Å—É—Ä—Å–æ–≤ –∏–≥—Ä–æ–∫–∞
                gameRoom.state.players.onAdd((playerData, playerName) => {
                    if (playerName === myName) {
                        playerResources.wood = playerData.wood || 0;
                        playerResources.stone = playerData.stone || 0;
                        playerResources.scrap = playerData.scrap || 0;
                        document.getElementById('player-resources').innerText = `–î–µ—Ä–µ–≤–æ: ${playerResources.wood} | –ö–∞–º–µ–Ω—å: ${playerResources.stone} | –°–∫—Ä–∞–ø: ${playerResources.scrap}`;

                        playerData.onChange(() => {
                            playerResources.wood = playerData.wood || 0;
                            playerResources.stone = playerData.stone || 0;
                            playerResources.scrap = playerData.scrap || 0;
                            document.getElementById('player-resources').innerText = `–î–µ—Ä–µ–≤–æ: ${playerResources.wood} | –ö–∞–º–µ–Ω—å: ${playerResources.stone} | –°–∫—Ä–∞–ø: ${playerResources.scrap}`;
                        });
                    }
                });

                // –ü–µ—Ä–≤–∏—á–Ω–∞—è —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
                gameRoom.state.hexes.forEach((hexData, hexId) => {
                    console.log("Initial hex:", hexId, hexData.owner);
                    capturedHexes.set(hexId, { owner: hexData.owner, color: hexData.color, type: hexData.type, building: hexData.building });
                });
                drawMap();

                // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —é–Ω–∏—Ç–æ–≤
                gameRoom.state.units.onAdd((unitData, unitId) => {
                    clientUnits.set(unitId, unitData);

                    // Center camera on the very first unit we receive if it belongs to us
                    if (unitData.owner === myName && document.getElementById('debug-info').innerText === '–°–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!' && clientUnits.size === 1) {
                        // wait a bit for rendering to initialize
                        setTimeout(centerCameraOnPlayer, 500);
                    }

                    unitData.onChange(() => {
                        clientUnits.set(unitId, unitData);
                    });
                });
                gameRoom.state.units.onRemove((unitData, unitId) => {
                    clientUnits.delete(unitId);
                    if (window.selectedUnitId === unitId) window.selectedUnitId = null;
                });

                // –ü—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ –≥–µ–∫—Å–∞
                gameRoom.state.hexes.onAdd((hexData, hexId) => {
                    console.log("Hex added:", hexId, hexData.owner);
                    capturedHexes.set(hexId, { owner: hexData.owner, color: hexData.color, type: hexData.type, building: hexData.building });
                    
                    // –ï—Å–ª–∏ —ç—Ç–æ –Ω–∞—à –∑–∞—Ö–≤–∞—Ç (–Ω–æ –Ω–µ –ø—Ä–∏ –ø–µ—Ä–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–µ)
                    if (hexData.owner === myName && document.getElementById('debug-info').innerText === '–°–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!') {
                        showToast(`–°–µ–∫—Ç–æ—Ä ${hexId} –∑–∞—Ö–≤–∞—á–µ–Ω/–æ—Ç–∫—Ä—ã—Ç!`, 'success');
                    } else if (hexData.owner && hexData.owner !== myName && document.getElementById('debug-info').innerText === '–°–≤—è–∑—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞!') {
                        // showToast(`${hexData.owner} –∑–∞—Ö–≤–∞—Ç–∏–ª –≥–µ–∫—Å!`, 'info'); // Can be noisy with fog of war
                    }

                    hexData.onChange(() => {
                        console.log("Hex updated:", hexId, hexData.owner);
                        capturedHexes.set(hexId, { owner: hexData.owner, color: hexData.color, type: hexData.type, building: hexData.building });
                        drawMap();
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –µ—Å–ª–∏ –º–µ–Ω—é –æ—Ç–∫—Ä—ã—Ç–æ
                        if (document.getElementById('player-menu').classList.contains('active')) {
                            updateProfileStats();
                        }
                    });
                    
                    drawMap();
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –µ—Å–ª–∏ –º–µ–Ω—é –æ—Ç–∫—Ä—ã—Ç–æ
                    if (document.getElementById('player-menu').classList.contains('active')) {
                        updateProfileStats();
                    }
                });

                gameRoom.state.hexes.onRemove((hexData, hexId) => {
                    console.log("Hex removed:", hexId);
                    capturedHexes.delete(hexId);
                    drawMap();
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –µ—Å–ª–∏ –º–µ–Ω—é –æ—Ç–∫—Ä—ã—Ç–æ
                    if (document.getElementById('player-menu').classList.contains('active')) {
                        updateProfileStats();
                    }
                });

                // –°–ª—É—à–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ —ç–Ω–µ—Ä–≥–∏–∏
                gameRoom.onMessage("energyUpdate", (data) => {
                    currentEnergy = data.energy;
                    const energyPercent = (currentEnergy / 10) * 100;
                    document.getElementById('energy-fill').style.width = `${energyPercent}%`;
                    document.getElementById('energy-text').innerText = `–≠–Ω–µ—Ä–≥–∏—è: ${currentEnergy}/10`;
                    
                    if (document.getElementById('player-menu').classList.contains('active')) {
                        document.getElementById('stat-energy').innerText = `${currentEnergy}/10`;
                    }
                });

                // –°–ª—É—à–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ–± –∏–≥—Ä–æ–∫–µ (–∏–∑ SQLite)
                gameRoom.onMessage("playerInfo", (data) => {
                    console.log("Player registered:", data);
                    // –ú–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–±—â–µ–≥–æ –∫–æ–ª-–≤–∞ –∑–∞—Ö–≤–∞—Ç–æ–≤
                });

                // –°–ª—É—à–∞–µ–º –æ—à–∏–±–∫–∏
                gameRoom.onMessage("error", (data) => {
                    tg.HapticFeedback.notificationOccurred('error');
                    showToast(data.message, 'error');
                    const oldText = document.getElementById('debug-info').innerText;
                    document.getElementById('debug-info').innerText = data.message;
                    document.getElementById('debug-info').style.color = '#ff4d00';
                    setTimeout(() => {
                        document.getElementById('debug-info').innerText = oldText;
                        document.getElementById('debug-info').style.color = '#a2a2bd';
                    }, 2000);
                });

                gameRoom.onMessage("success", (data) => {
                    tg.HapticFeedback.notificationOccurred('success');
                    showToast(data.message, 'success');
                });

                gameRoom.onMessage("vfx", (data) => {
                    // Create floating text at specific location
                    // If q,r provided, map to x,y
                    if (data.q !== undefined && data.r !== undefined) {
                        const hSize = 35;
                        const x = hSize * Math.sqrt(3) * (data.q + data.r / 2);
                        const y = hSize * 3 / 2 * data.r;
                        floatingTexts.push({
                            text: data.text,
                            x: x + (Math.random() * 20 - 10), // slight random offset
                            y: y - 20,
                            alpha: 1.0,
                            color: data.color || '#4ecca3',
                            scale: data.scale || 1.0
                        });
                    }
                });

                drawMap();

            } catch (e) {
                console.error("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è:", e);
                document.getElementById('debug-info').innerText = '–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è :(';
            }
        }

        connect();

        // --- 4. –û–ë–†–ê–ë–û–¢–ö–ê –ö–õ–ò–ö–û–í ---
        // –ó–∞–∫—Ä—ã–≤–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–Ω–æ–µ –º–µ–Ω—é –ø—Ä–∏ –∫–ª–∏–∫–µ –≤ –ª—é–±–æ–º –º–µ—Å—Ç–µ
        window.addEventListener('click', () => {
            closeContextMenu();
        });

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–∏ –º—ã—à–∏ (–ü–ö–ú)
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault(); // –û—Ç–∫–ª—é—á–∞–µ–º —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –º–µ–Ω—é –±—Ä–∞—É–∑–µ—Ä–∞

            const hSize = getHexSize();
            const oX = getOriginX();
            const oY = getOriginY();

            const x = e.clientX - oX;
            const y = e.clientY - oY;

            const q_raw = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / hSize;
            const r_raw = (2 / 3 * y) / hSize;

            selectedHex = hexRound(q_raw, r_raw);
            const key = `${selectedHex.q},${selectedHex.r}`;
            const data = capturedHexes.get(key);

            // –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω —é–Ω–∏—Ç –∏ —ç—Ç–æ –ø—Ä–∞–≤—ã–π –∫–ª–∏–∫, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –µ–≥–æ –≤ —ç—Ç—É —Ç–æ—á–∫—É
            if (window.selectedUnitId && e.button === 2) {
                gameRoom.send("moveUnit", { unitId: window.selectedUnitId, q: selectedHex.q, r: selectedHex.r });

                // Show a waypoint effect locally
                particles.push({
                    x: x, y: y,
                    vx: 0, vy: 0,
                    life: 1.0, color: '#4ecca3', type: 'smoke', size: 10
                });
                return;
            }

            // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞—à–µ –º–µ–Ω—é
            const menu = document.getElementById('context-menu');
            menu.style.display = 'block';
            menu.style.left = `${e.clientX}px`;
            menu.style.top = `${e.clientY}px`;

            // Show/Hide Build TC option
            if (window.selectedUnitId && (!data || !data.building)) {
                document.getElementById('context-build-tc').style.display = 'block';
            } else {
                document.getElementById('context-build-tc').style.display = 'none';
            }

            // –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –≤ –º–µ–Ω—é
            document.getElementById('context-title').innerText = `–ì–µ–∫—Å [${key}]`;

            console.log(`[–ü–ö–ú] –ù–∞–∂–∞—Ç –æ–±—ä–µ–∫—Ç: –ì–µ–∫—Å (${key})`);
            console.log(`[–ü–ö–ú] –í–ª–∞–¥–µ–ª–µ—Ü: ${data ? data.owner : '–ù–∏–∫—Ç–æ'}`);
            
            tg.HapticFeedback.impactOccurred('medium');
        });

        canvas.addEventListener('pointerdown', (e) => {
            if (e.button === 1 || e.button === 2) return; // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º —Å—Ä–µ–¥–Ω—é—é –∏ –ø—Ä–∞–≤—É—é –∫–Ω–æ–ø–∫–∏
            if (!gameRoom) return; // –ï—Å–ª–∏ –µ—â–µ –Ω–µ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å, –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫–∏

            const hSize = getHexSize();
            const oX = getOriginX();
            const oY = getOriginY();

            const x = e.clientX - oX;
            const y = e.clientY - oY;

            // Check if a unit was clicked
            let clickedUnit = null;
            clientUnits.forEach(unit => {
                let uX = unit.x * zoom;
                let uY = unit.y * zoom;
                let drawSize = 25 * zoom;

                let dx = x - uX;
                let dy = y - uY;
                if (Math.sqrt(dx*dx + dy*dy) <= drawSize) {
                    clickedUnit = unit;
                }
            });

            if (clickedUnit) {
                if (clickedUnit.owner === myName) {
                    window.selectedUnitId = clickedUnit.id;
                    drawMap();
                } else {
                    window.selectedUnitId = null;
                    drawMap();
                }
                return;
            }

            const q = (Math.sqrt(3) / 3 * x - 1 / 3 * y) / hSize;
            const r = (2 / 3 * y) / hSize;

            const hexObj = hexRound(q, r);

            // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞ —Å–µ—Ä–≤–µ—Ä –∫–æ–º–∞–Ω–¥—É –Ω–∞ –∑–∞—Ö–≤–∞—Ç!
            gameRoom.send("claimHex", { q: hexObj.q, r: hexObj.r });
            window.selectedUnitId = null;
            drawMap();
        });

        function hexRound(q, r) {
            let s = -q - r;
            let rq = Math.round(q);
            let rr = Math.round(r);
            let rs = Math.round(s);
            const qDiff = Math.abs(rq - q);
            const rDiff = Math.abs(rr - r);
            const sDiff = Math.abs(rs - s);
            if (qDiff > rDiff && qDiff > sDiff) { rq = -rr - rs; }
            else if (rDiff > sDiff) { rr = -rq - rs; }
            else { rs = -rq - rr; }
            return { q: rq, r: rr };
        }
    </script>
</body>

</html>